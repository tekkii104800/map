剩下的task

敌人：
火山口								基本完成，不需要描画
岩石								基本完成，剩素材
中boss							基本完成，剩子弹prefab

蓝色道具

player的防护盾

Respawn系统
玩家位置归0,0，重新载入后让scroll动

到达火山口时scroll停止移动，背景也停止移动，背景变红

打掉一个小怪涨100分，30000分时残机+1，保留最高分

爆炸effect

title->游戏开始，屏幕上会显示半秒左右的Game Start

死亡：画面定格（update停止），重载游戏后没有特殊UI

Gameover：画面定格（update停止），显示Game Over，闪几下到Result画面

reset stage时需要reset的东西
player：各项指标：速度回到初始，mode回到normal，option数量回到0，barrier回到false
屏幕上已有的enemy和item删除（通过文件夹操作？）

title时reset的东西
分数 残机 

存档点：开头，
快到陆地的时候，开始后有一红二蓝garun，然后是两只红固定飞出来
在断裂小山前，开始后是两只红固定，三只蓝固定（？）
一蓝一红同时飞出来，后面跟着一红二蓝，地上出现炮

改进点
激光连射
player速度设定
背景分层次
player加速演出

//火山
public class Volcano : MonoBehaviour
{
    public GameObject Rock;

    public float ShootTimeInterval = 0.5f;
    private float ShootTime = 0.0f;
    public float AngleMax = 150.0f;
    public float AngleMin = 30.0f;
    public bool IsShooting { get; set; }
    // Start is called before the first frame update
    void Start()
    {
        IsShooting = true;
    }

    // Update is called once per frame
    void Update()
    {
        if(IsShooting)
        {
            ShootTime += Time.deltaTime;
            if (ShootTime > ShootTimeInterval)
            {
                GameObject rock = GameObject.Instantiate(Rock, transform.position, new Quaternion(0, 0, 0, 0));
                float angle = Random.Range(AngleMin, AngleMax);
                rock.GetComponent<Rock>().CreateDir = new Vector3(Mathf.Cos(Mathf.Deg2Rad * angle), Mathf.Sin(Mathf.Deg2Rad * angle), 0);
                ShootTime = 0.0f;
            }              
        }
    }
}

//岩
public class Rock : MonoBehaviour
{
    //是继承了enemy的类
    public Vector3 CreateDir { get; set; }

    public float CreateSpeed = 10.0f;

    public float Gravity = 1.0f;

    private Vector3 Speed=Vector3.zero;

    // Start is called before the first frame update
    void Start()
    {
        //可删除开关一开始就打开
        Speed = CreateDir * CreateSpeed;
    }

    // Update is called once per frame
    void Update()
    {
        Speed += new Vector3(0, -1, 0)  * Gravity;

        transform.position += Speed * Time.deltaTime;
    }
}

//ボス
public class Boss : MonoBehaviour
{
    enum BossRoutine
    {
        Entrance,
        TopToMiddle,
        MiddleToBottom,
        BottomToMiddle,
        MiddleToTop,
    }

    public GameObject Bullet;

    public float TopPosY;
    public float MiddlePosY;
    public float BottomPosY;
    public float RightPosX;

    public float MoveSpeed = 5.0f;

    private BossRoutine Routine;

    public float ShootWaitTimeMax = 0.5f;
    private float ShootWaitTime = 0.0f;
    // Start is called before the first frame update
    void Start()
    {
        Routine = BossRoutine.Entrance;
    }

    // Update is called once per frame
    void Update()
    {
        switch (Routine)
        {
            case BossRoutine.Entrance:
                entrance();
                break;
            case BossRoutine.TopToMiddle:
                topToMiddel();
                break;
            case BossRoutine.MiddleToBottom:
                middleToBottom();
                break;
            case BossRoutine.BottomToMiddle:
                bottomToMiddle();
                break;
            case BossRoutine.MiddleToTop:
                middleToTop();
                break;
            default:
                break;
        }
    }

    private void entrance()
    {
        if (this.transform.position.y < MiddlePosY)
        {
            this.transform.position += new Vector3(0, 1, 0) * Time.deltaTime * MoveSpeed;
        }
        else if(this.transform.position.x<RightPosX)
        {
            this.transform.position += new Vector3(1, 0, 0) * Time.deltaTime * MoveSpeed;
        }
        else if(this.transform.position.y < TopPosY)
        {
            this.transform.position += new Vector3(0, 1, 0) * Time.deltaTime * MoveSpeed;
        }
        else
        {
            if(ShootWaitTime == 0.0f)
            {
                shoot();
            }
            ShootWaitTime += Time.deltaTime;
            if(ShootWaitTime > ShootWaitTimeMax)
            {
                ShootWaitTime = 0.0f;
                Routine = BossRoutine.TopToMiddle;
            }            
        }
    }

    private void topToMiddel()
    {
        if(this.transform.position.y > MiddlePosY)
        {
            this.transform.position += new Vector3(0, -1, 0) * Time.deltaTime * MoveSpeed;
        }
        else
        {
            if (ShootWaitTime == 0.0f)
            {
                shoot();
            }
            ShootWaitTime += Time.deltaTime;
            if (ShootWaitTime > ShootWaitTimeMax)
            {
                ShootWaitTime = 0.0f;
                Routine = BossRoutine.MiddleToBottom;
            }
        }
    }

    private void middleToBottom()
    {
        if (this.transform.position.y > BottomPosY)
        {
            this.transform.position += new Vector3(0, -1, 0) * Time.deltaTime * MoveSpeed;
        }
        else
        {
            if (ShootWaitTime == 0.0f)
            {
                shoot();
            }
            ShootWaitTime += Time.deltaTime;
            if (ShootWaitTime > ShootWaitTimeMax)
            {
                ShootWaitTime = 0.0f;
                Routine = BossRoutine.BottomToMiddle;
            }
        }
    }

    private void bottomToMiddle()
    {
        if (this.transform.position.y < MiddlePosY)
        {
            this.transform.position += new Vector3(0, 1, 0) * Time.deltaTime * MoveSpeed;
        }
        else
        {
            if (ShootWaitTime == 0.0f)
            {
                shoot();
            }
            ShootWaitTime += Time.deltaTime;
            if (ShootWaitTime > ShootWaitTimeMax)
            {
                ShootWaitTime = 0.0f;
                Routine = BossRoutine.MiddleToTop;
            }
        }
    }

    private void middleToTop()
    {
        if (this.transform.position.y < TopPosY)
        {
            this.transform.position += new Vector3(0, 1, 0) * Time.deltaTime * MoveSpeed;
        }
        else
        {
            if (ShootWaitTime == 0.0f)
            {
                shoot();
            }
            ShootWaitTime += Time.deltaTime;
            if (ShootWaitTime > ShootWaitTimeMax)
            {
                ShootWaitTime = 0.0f;
                Routine = BossRoutine.TopToMiddle;
            }
        }
    }

    private void shoot()
    {
        Vector3[] BulletPosDiff = new Vector3[4];
        BulletPosDiff[0] = new Vector3(-1.3f, 1.4f, 0.0f);
        BulletPosDiff[1] = new Vector3(-2.4f, 0.6f, 0.0f);
        BulletPosDiff[2] = new Vector3(-2.4f, -0.6f, 0.0f);
        BulletPosDiff[3] = new Vector3(-1.3f, -1.4f, 0.0f);

        for (int i = 0; i < 4; i++)
        {
            GameObject bullet = GameObject.Instantiate(Bullet, transform.position+ BulletPosDiff[i], new Quaternion(0, 0, 0, 0));
            bullet.GetComponent<EnemyBullet>().MoveDir = new Vector3(-1, 0, 0);
        }     
    }
}
